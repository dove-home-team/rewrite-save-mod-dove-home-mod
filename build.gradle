plugins {
    id "acl" version "$acl_version"
    id 'java'
}

rootProject.buildDir = ".gradle/build/"

allprojects {

    repositories {

        maven {
            url = rootProject.file("rootmaven")
        }
		maven { url "https://github.com/XenFork/Architectury-compatibility-layer/rootmaven/" }
        maven { url "https://maven.shedaniel.me/" }
        maven {
            url = 'https://www.cursemaven.com'
            content {
                includeGroup "curse.maven"
            }
        }
        maven {
            name = "modmenu"
            url = "https://maven.terraformersmc.com/releases/"
        }
        maven {

            name = "Resourceful Bees Maven"
            url = "https://nexus.resourcefulbees.com/repository/maven-public/"
        }
        maven {
            url = "https://maven.saps.dev/minecraft"
            content {
                includeGroup "dev.latvian.mods"
            }
        }
        maven {
            name = 'GeckoLib'
            url 'https://dl.cloudsmith.io/public/geckolib3/geckolib/maven/'
        }

    }

    tasks.withType(JavaCompile).configureEach {
        options.encoding = "UTF-8"
        options.release.set(17)
    }

    java {
        withSourcesJar()
    }
}



String property = getProperty("sts.projects")
for (final def name in property.split(",") ) {
    project(":$name-common") {
//        project.buildDir = "/build/common"
        archivesBaseName = "$name"
        version = getProperty("${name}_version")
        loom {
            def path = file("src/main/resources/${name}.accesswidener")
            if (path.exists()) {
                accessWidenerPath = path
            }
        }

        sourceSets {
            main {
                resources {
                    srcDirs += file("src/main/generated/resources").absolutePath
                    exclude ".cache"
                }
            }
        }



        publishing {
            publications {
                mavenCommon(MavenPublication) {
                    artifactId =  project.name + "-" + minecraft_version
                    from components.java
                }
            }

            repositories {
                maven {
                    url rootProject.file("rootmaven")
                }
            }
        }
    }
    project(":$name-fabric") {
//        project.buildDir = "../common/build/fabric"
        apply plugin: "com.github.johnrengelman.shadow"

        archivesBaseName = "$name"
        version = getProperty("${name}_version")


        loom {
            def path = project(":$name-common").loom.accessWidenerPath
            if (path != null) {
                accessWidenerPath = path
            }
            for (final def config in runConfigs) {
                config.runDir("../common/run/fabric")
            }

        }

        sourceSets {
            main {
                resources {
                    srcDirs += rootProject.file("$name/common/src/fabric/resources")
                    srcDirs -= file("src/main/resources")
                }
                java {
                    srcDirs += rootProject.file("$name/common/src/fabric/java")
                    srcDirs -= file("src/main/java")
                }
            }
        }

        architectury {
            platformSetupLoomIde()
            fabric()
        }

        configurations {
            common
            shadowCommon // Don't use shadow from the shadow plugin because we don't want IDEA to index this.
            compileClasspath.extendsFrom common
            runtimeClasspath.extendsFrom common
            developmentFabric.extendsFrom common
        }

        dependencies {

            common(project(path: ":$name-common", configuration: "namedElements")) { transitive false }
            shadowCommon(project(path: ":$name-common", configuration: "transformProductionFabric")) { transitive false }
        }

        processResources {
            inputs.property "version", project.version
            inputs.property "modid", name
            inputs.property "display_name", project.name
            inputs.property "license_type", license_type

            filesMatching("fabric.mod.json") {
                expand "version": project.version,
                        "modid": name,
                        "display_name": project.name,
                        "license_type": license_type
            }
        }

        shadowJar {
            configurations = [project.configurations.shadowCommon]
            archiveClassifier.set("dev-shadow")
        }

        remapJar {
            inputFile.set shadowJar.archiveFile
            dependsOn shadowJar
            archiveClassifier.set(null)
        }

        jar {
            archiveClassifier.set("dev")
        }

        sourcesJar {
            def commonSources = project(":$name-common").sourcesJar
            dependsOn commonSources
            from commonSources.archiveFile.map { zipTree(it) }
        }

        components.java {
            withVariantsFromConfiguration(project.configurations.shadowRuntimeElements) {
                skip()
            }
        }

        publishing {
            publications {
                mavenFabric(MavenPublication) {
                    artifactId = project.name + "-" + minecraft_version
                    from components.java
                }
            }

            // See https://docs.gradle.org/current/userguide/publishing_maven.html for information on how to set up publishing.
            repositories {
                maven {
                    url rootProject.file("rootmaven")
                }
            }
        }

    }
    project(":$name-forge") {
//        project.buildDir = "../common/build/forge"
        apply plugin: "com.github.johnrengelman.shadow"

        archivesBaseName = "$name"
        version = getProperty("${name}_version")

        architectury {
            platformSetupLoomIde()
            forge()
        }

        loom {
            def path = project(":$name-common").loom.accessWidenerPath
            if (path != null) {
                accessWidenerPath = path
            }
            forge {

                mixinConfig "${name}.mixins.json", "${name}-common.mixins.json"
                if (path != null) {
                    convertAccessWideners.set(true)
                }
                runs {
                    datagen {
                        data()
                        programArgs("--all", "--mod", "${name}")
                        programArgs("--output", project(":$name-common").file("src/main/generated/resources").absolutePath)
                    }
                }
                for (final def config in runConfigs) {
                    config.runDir("../common/run/fabric")
                }

            }

        }

        sourceSets {
            main {
                java {
                    srcDirs += rootProject.file("$name/common/src/main/datagen")
                    srcDirs += rootProject.file("$name/common/src/forge/java")
                    srcDirs -= file("src/main/java")
                }

                resources {
                    srcDirs += rootProject.file("$name/common/src/main/forge")
                    srcDirs += rootProject.file("$name/common/src/forge/resources")
                    srcDirs -= file("src/main/resources")
                }
            }
        }

        configurations {
            common
            shadowCommon // Don't use shadow from the shadow plugin because we don't want IDEA to index this.
            compileClasspath.extendsFrom common
            runtimeClasspath.extendsFrom common
            developmentForge.extendsFrom common
        }

        dependencies {
            common(project(path: ":$name-common", configuration: "namedElements")) { transitive false }
            shadowCommon(project(path: ":$name-common", configuration: "transformProductionForge")) { transitive = false }
        }

        processResources {
            inputs.property "version", project.version
            inputs.property "modid", name
            inputs.property "display_name", project.name
            inputs.property "license_type", license_type

            filesMatching("META-INF/mods.toml") {
                expand "version": project.version,
                        "modid": name,
                        "display_name": project.name,
                        "license_type": license_type
            }
        }

        shadowJar {
            exclude "fabric.mod.json"

            configurations = [project.configurations.shadowCommon]
            archiveClassifier.set("dev-shadow")
        }

        remapJar {
            inputFile.set shadowJar.archiveFile
            dependsOn shadowJar
            archiveClassifier.set(null)
        }

        jar {
            archiveClassifier.set("dev")
        }

        sourcesJar {
            def commonSources = project(":$name-common").sourcesJar
            dependsOn commonSources
            from commonSources.archiveFile.map { zipTree(it) }
        }

        components.java {
            withVariantsFromConfiguration(project.configurations.shadowRuntimeElements) {
                skip()
            }
        }

        publishing {
            publications {
                mavenForge(MavenPublication) {
                    artifactId =  project.name + "-" + minecraft_version
                    from components.java
                }
            }

            // See https://docs.gradle.org/current/userguide/publishing_maven.html for information on how to set up publishing.
            repositories {
                maven {
                    url rootProject.file("rootmaven")
                }
            }
        }
    }

    task "${name}_publish"(dependsOn: [
            project("$name-common").tasks.getByName("publish"),
            project("$name-fabric").tasks.getByName("publish"),
            project("$name-forge").tasks.getByName("publish")
    ],
            group: "publish") {}

}

