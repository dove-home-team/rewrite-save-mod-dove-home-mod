plugins {
    id "architectury-plugin" version "3.4-SNAPSHOT"
    id "dev.architectury.loom" version "1.4-SNAPSHOT" apply false
    id "com.github.johnrengelman.shadow" version "7.1.2" apply false
}

architectury {
    minecraft = rootProject.minecraft_version
}

allprojects {
    apply plugin: "java"
    apply plugin: "architectury-plugin"
    apply plugin: "maven-publish"

    archivesBaseName = rootProject.archives_base_name
    version = rootProject.mod_version
    group = rootProject.maven_group

    repositories {
        maven {
            name = 'ParchmentMC'
            url = 'https://maven.parchmentmc.org'
        }
        maven {
            url = rootProject.file("rootmaven")
        }
        maven { url "https://maven.shedaniel.me/" }
        maven {
            url = 'https://www.cursemaven.com'
            content {
                includeGroup "curse.maven"
            }
        }
        maven {
            name = "modmenu"
            url = "https://maven.terraformersmc.com/releases/"
        }
        maven {

            name = "Resourceful Bees Maven"
            url = "https://nexus.resourcefulbees.com/repository/maven-public/"
        }

    }

    tasks.withType(JavaCompile) {
        options.encoding = "UTF-8"
        options.release = 17
    }

    java {
        withSourcesJar()
    }
}

subprojects {
    apply plugin: "dev.architectury.loom"
    loom {
        silentMojangMappingsLicense()
    }

    dependencies {
        minecraft "com.mojang:minecraft:${rootProject.minecraft_version}"
        // The following line declares the mojmap mappings, you may use other mappings as well
        mappings loom.layered() {
            officialMojangMappings()
            parchment("org.parchmentmc.data:parchment-${rootProject.pachment_version}@zip")
        }
    }
}

def names = [
        "bakalib"
        , "dovehomemod"
        , "dovecore"
]

for (final def name in names ) {
    project(":$name-common") {

        archivesBaseName = "$name"
        version = getProperty("${name}_version")
        loom {
            def path = file("src/main/resources/${archivesBaseName}.accesswidener")
            if (path.exists()) {
                accessWidenerPath = path
            }
        }

        sourceSets {
            main {
                resources {
                    srcDirs += project(":$name-forge").file("src/main/generated/resources").absolutePath
                    exclude ".cache"
                }
            }
        }

        dependencies {

            // We depend on fabric loader here to use the fabric @Environment annotations and get the mixin dependencies
            // Do NOT use other classes from fabric loader
            modImplementation "net.fabricmc:fabric-loader:${rootProject.fabric_loader_version}"
            // Remove the next line if you don't want to depend on the API
            modApi "dev.architectury:architectury:${rootProject.architectury_version}"
        }

        architectury {
            common("fabric", "forge")
        }

        publishing {
            publications {
                mavenCommon(MavenPublication) {
                    artifactId =  project.name + "-" + minecraft_version
                    from components.java
                }
            }

            repositories {
                maven {
                    url rootProject.file("rootmaven")
                }
            }
        }
    }
    project(":$name-fabric") {
        apply plugin: "com.github.johnrengelman.shadow"

        archivesBaseName = "$name"
        version = getProperty("${name}_version")

        loom {
            def path = project(":$name-common").loom.accessWidenerPath
            if (path != null) {
                accessWidenerPath = path
            }

        }

        architectury {
            platformSetupLoomIde()
            fabric()
        }

        configurations {
            common
            shadowCommon // Don't use shadow from the shadow plugin because we don't want IDEA to index this.
            compileClasspath.extendsFrom common
            runtimeClasspath.extendsFrom common
            developmentFabric.extendsFrom common
        }

        dependencies {
            modImplementation "net.fabricmc:fabric-loader:${rootProject.fabric_loader_version}"
            modApi "net.fabricmc.fabric-api:fabric-api:${rootProject.fabric_api_version}"
            // Remove the next line if you don't want to depend on the API
            modApi "dev.architectury:architectury-fabric:${rootProject.architectury_version}"

            common(project(path: ":$name-common", configuration: "namedElements")) { transitive false }
            shadowCommon(project(path: ":$name-common", configuration: "transformProductionFabric")) { transitive false }
        }

        processResources {
            inputs.property "version", project.version
            inputs.property "modid", name
            inputs.property "display_name", project.name
            inputs.property "license_type", license_type

            filesMatching("fabric.mod.json") {
                expand "version": project.version,
                        "modid": name,
                        "display_name": project.name,
                        "license_type": license_type
            }
        }

        shadowJar {
            configurations = [project.configurations.shadowCommon]
            archiveClassifier.set("dev-shadow")
        }

        remapJar {
            inputFile.set shadowJar.archiveFile
            dependsOn shadowJar
            archiveClassifier.set(null)
        }

        jar {
            archiveClassifier.set("dev")
        }

        sourcesJar {
            def commonSources = project(":$name-common").sourcesJar
            dependsOn commonSources
            from commonSources.archiveFile.map { zipTree(it) }
        }

        components.java {
            withVariantsFromConfiguration(project.configurations.shadowRuntimeElements) {
                skip()
            }
        }

        publishing {
            publications {
                mavenFabric(MavenPublication) {
                    artifactId =  project.name + "-" + minecraft_version
                    from components.java
                }
            }

            // See https://docs.gradle.org/current/userguide/publishing_maven.html for information on how to set up publishing.
            repositories {
                maven {
                    url rootProject.file("rootmaven")
                }
            }
        }

    }
    project(":$name-forge") {
        apply plugin: "com.github.johnrengelman.shadow"

        archivesBaseName = "$name"
        version = getProperty("${name}_version")

        architectury {
            platformSetupLoomIde()
            forge()
        }

        loom {
            def path = project(":$name-common").loom.accessWidenerPath
            if (path != null) {
                accessWidenerPath = path
            }
            forge {
                mixinConfig "${name}.mixins.json", "${name}-common.mixins.json"
                if (path != null) {
                    convertAccessWideners.set(true)
                }
                runs {
                    datagen {
                        data()
                        programArgs("--all", "--mod", "dovehomemod")
                        programArgs("--output", file("src/main/generated/resources").absolutePath)
                    }
                }

            }

        }

        configurations {
            common
            shadowCommon // Don't use shadow from the shadow plugin because we don't want IDEA to index this.
            compileClasspath.extendsFrom common
            runtimeClasspath.extendsFrom common
            developmentForge.extendsFrom common
        }

        dependencies {

            forge "net.minecraftforge:forge:${rootProject.forge_version}"
            // Remove the next line if you don't want to depend on the API
            modApi "dev.architectury:architectury-forge:${rootProject.architectury_version}"

            common(project(path: ":$name-common", configuration: "namedElements")) { transitive false }
            shadowCommon(project(path: ":$name-common", configuration: "transformProductionForge")) { transitive = false }
        }

        processResources {
            inputs.property "version", project.version
            inputs.property "modid", name
            inputs.property "display_name", project.name
            inputs.property "license_type", license_type

            filesMatching("META-INF/mods.toml") {
                expand "version": project.version,
                        "modid": name,
                        "display_name": project.name,
                        "license_type": license_type
            }
        }

        shadowJar {
            exclude "fabric.mod.json"

            configurations = [project.configurations.shadowCommon]
            archiveClassifier.set("dev-shadow")
        }

        remapJar {
            inputFile.set shadowJar.archiveFile
            dependsOn shadowJar
            archiveClassifier.set(null)
        }

        jar {
            archiveClassifier.set("dev")
        }

        sourcesJar {
            def commonSources = project(":$name-common").sourcesJar
            dependsOn commonSources
            from commonSources.archiveFile.map { zipTree(it) }
        }

        components.java {
            withVariantsFromConfiguration(project.configurations.shadowRuntimeElements) {
                skip()
            }
        }

        publishing {
            publications {
                mavenForge(MavenPublication) {
                    artifactId =  project.name + "-" + minecraft_version
                    from components.java
                }
            }

            // See https://docs.gradle.org/current/userguide/publishing_maven.html for information on how to set up publishing.
            repositories {
                maven {
                    url rootProject.file("rootmaven")
                }
            }
        }
    }
     task "${name}_publish"(dependsOn: [
            project("$name-common").tasks.getByName("publish"),
            project("$name-fabric").tasks.getByName("publish"),
            project("$name-forge").tasks.getByName("publish")
    ],
     group: "publish") {}


}
